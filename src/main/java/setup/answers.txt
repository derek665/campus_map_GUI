CSE 331 Homework 3.  Answers to Written questions.
Edit this file to supply your answers.

Name:  Derek Chan

Problem 6.

(a) The original code had (n <= 0) for the test case,
    so each time a 0 is passed, it causes an exception.
    I fixed it by changing to (n < 0) since 0 is a legal argument for n

(b) The original code had (n <= 2) to return 1 for a base case.
    But for n == 2, the answer should be 1 + 1 instead of 1.
    So I fixed it by changing the test to (n < 2)

(c) The original code had getFibTerm(n - 1) - getFibTerm(n - 2),
    which made the final result wrong. I changed the line to
    getFibTerm(n - 1) + getFibTerm(n - 2) and the final result is correct


Problem 7. 

Ball.java
I changed the constructor to this.volume = volume,
so the parameter is stored to the field of the class.
I also changed the getVolume() method to return the volume field instead of 0

BallContainer.java
I have a volume field to keep track of the current volume,
I believe this is the better approach because even though there are a few extra lines of code
in the add & remove method, the volume method does not need to recompute the volume every time I call it

Box.java

a. An implementation I used is not to use a TreeSet field, not have extra codes in each method to add/remove set.
In the getSmallest method have local TreeSet variable with Comparator, add ballContainer to TreeSet,
then return the iterator for the TreeSet.

b. Another implementation is add a private TreeSet with Comparator field, it keeps track of the sorted contents as the program runs
the TreeSet adds a ball to the sorted order when add() is called,
remove a ball from the treeSet when remove() is called, and clear when clear() is called.
Then just return the treeSet's iterator when called, no extra codes are needed in that method.

Implementation B is faster than A because there is no need to go through the ballContainer each time when
getSmallest is called, A just simply returns an iterator. But B might have trouble when removing duplicates



