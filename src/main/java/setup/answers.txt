CSE 331 Homework 3.  Answers to Written questions.
Edit this file to supply your answers.

Name:  Derek Chan

Problem 6.

(a) The original code had (n <= 0) for the test case,
    so each time a 0 is passed, it causes an exception.
    I fixed it by changing to (n < 0) since 0 is a legal argument for n

(b) The original code had (n <= 2) to return 1 for a base case.
    But for n == 2, the answer should be 1 + 1 instead of 1.
    So I fixed it by changing the test to (n < 2)

(c) The original code had getFibTerm(n - 1) - getFibTerm(n - 2),
    which made the final result wrong. I changed the line to
    getFibTerm(n - 1) + getFibTerm(n - 2) and the final result is correct


Problem 7. 

Ball.java
I changed the constructor to this.volume = volume,
so the parameter is stored to the field of the class.
I also changed the getVolume() method to return the volume field instead of 0

BallContainer.java
I have a volume field to keep track of the current volume,
I believe this is the better approach because even though there are a few extra lines of code
in the add & remove method, the volume method does not need to recompute the volume every time I call it

Box.java
a. My implementation returns a new iterator each time it is called, I also include an additional class for the treeSet to be sorted.
It adds all the current balls in the ballcontainer to the comparator treeSet

b. Another implementations that I came up with is add to the treeSet each time the ballcontainer has a new ball,
remove a ball from the treeSet when remove is called. Then just return the treeSet's iterator when called, no extra codes are needed.

There is only one aspect which I can think of when b is better than a, there is no need to go through the container each time.
So maybe b is more efficient than a



