CSE 331 Homework.  Answers to written questions.
Edit this file to supply your answers.

Name:  Derek Chan

Problem 1. (Written exercises)

(a) 1. Abstraction function: The Nth element from the front of the queue = entries.get(N)
                             where the oldest (least recent) element is the first element

       Rep invariant: For any index i such that 0 <= i < entries.size()
                      entries.get(i) != null

    2. Abstraction function: if size == 0, then entries == []
                             Otherwise,
                             The front element of the queue = entries.get(front)
                             The second element of the queue = entries.get((front + 1) % entries.size())
                             ...
                             The last element of the queue = entries.get((front + (size - 1)) % entries.size())
                             where front is the pointer to the oldest (least recent) element of the queue.

       Rep invariant: For any index i such that 0 <= i < entries.size()
                      entries.get(i) != null
                      0 <= front < entries.size()
                      size >= 0

(b) a = [1,2]
    b = [2,3,4]
    c = [1,2,3]
    d = [1,2]
    e = [1,2,3,4]
    f = [1,2,3]
    g = [1,2]
    h = [2,3,4]

    a, d, g are equivalent
    b, h are equivalent
    c, f are equivalent

(c) 1. This won't create rep exposure because the return type is int, as well as ints as parameter

    2. Array is mutable, so we can possibly have rep exposure since the return type is array of String

    3. If the object Date is declared final, it is not mutable, and the returned Date does not create aliasing to the original Date object
       then there will be no rep exposure

    4. String is immutable object, so there won't be any rep exposure

    5. Certain iterator supports remove(), if the returned iterator iterates over the original object and has the remove() feature
       then it will have rep exposure
    6. if the constructor creates a pointer to the list rather than make a new copy, then client can change the content of the list
       and causes rep exposure


Problem 2.  (Graph interface/operations)
The graph starts off empty, then more nodes can be added via addNode(), we can also connect between nodes using addChild(). Calling getEdges()
returns all the children nodes with labels that are connected to the parent node, so client can see which nodes are linked to the parent node.
Client can also remove a specific edge from two nodes, also remove a node from the graph, the edges that has that node as child.

I did not include any other additional classes other than Graph, since I believe adding another class will add complexity
of the interface, and all the data in the graph are String, it is better to pass String into method than making another object
then pass it to the method for the client.

I include all the observer methods such as getNodes(), getEdges(), getLabels(), hasNode().
So the client can view what is in the graph without changing the contents

I only include a method isChildOf rather than isChildOf plus a method to test parent relationship is because for node A to be
a parent of node B. That means node B is the child of node A, so having another boolean type method is redundant when we can just swap the param


Problem 3.  (Testing strategy)
I used black box testing strategy since I do not know the implementation yet
I have tests for a lot of different possible combinations of graph according to the specification
such as empty graph, graph with nodes but without edges, graph with multiple nodes and some combinations of edges.
Edge case such as having a circular edge (same parent and child) was also included in the test file.
The implementation tests are slightly different from the spec test, since my Graph class included some method
like remove, some observers, and some methods throw exception when unwanted arguments are being passed.
I have to include tests for those operations, which for spec test I only include the addNode & addChild feature of the class.
So the implementation test has more tests than the spec test.


