CSE 331 Homework 4.  Answers to written questions.
Edit this file to supply your answers.

Name:  Derek Chan

Problem 0.

(a) r = p * q :
        set r = 0
        {inv1 : r = p_0 * q + p_1 * q + .... + p_(i - 1) * q, where p_i is the i-th term of p}
        foreach term, t_p in p {
            set j = 0
            {inv2 : j = t_p * q_0 + t_p * q_1 + ..... + t_p * q_(i - 1), where q_i is the i-term of q}
            foreach term, t_q in q {
                update j = j + t_p * t_q (call the polynomial addition here with j and (t_p * t_q))
                (t_p * t_q = coefficient of t_p * coefficient of t_q with degree of t_p + degree of t_q)
            }
            r = r + j (call the polynomial addition here with r and j)
        }

(b) r = p / q
    1st coefficient : the coefficient of the term with highest degree
    1st degree : the degree of the term with highest degree
        set quotient = 0
        set remainder = deep copy of p
        {inv : quotient = quotient + (1st remainder coefficient divided by 1st q coefficient, with degree of 1st remainder degree - 1st q degree) ;
               remainder = remainder - ((1st remainder coefficient divided by 1st q coefficient) * q) }
        while (remainder > 0 && (1st remainder degree >= 1st q degree)) {
             set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q (integer sub)) as degree
             update quotient = polyAddition(quotient, factor)
             update remainder = polyAddition(remainder,  polyMultiplication(polyMultiplication(q, factor)), -1))
        }


(c) (x^3 + x - 1) / (x + 1) = x^2 - x + 2
    p = (x^3 + x - 1)       q = (x + 1)
    quotient = 0        remainder = copy of p : (x^3 + x - 1)
    while (remainder > 0 && (1st remainder degree >= 1st q degree)) {
        Iteration 1: quotient = 0 ; remainder = (x^3 + x - 1) ; q = (x + 1)
                     [set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q) as degree]
                     factor = (1/1) * x^(3-1) = x^2
                     [update quotient = polyAddition(quotient, factor)]
                     quotient = 0 + x^2 = x^2
                     [update remainder = polyAddition(remainder, negate (polyMultiplication(q, factor)))]
                     remainder = (x^3 + x - 1) + (-(x + 1) * x^2) = (x^3 + x - 1) + (-x^3 - x^2) = -x^2 + x - 1

        Iteration 2: quotient = (x^2) ; remainder = (-x^2 + x - 1) ; q = (x + 1)
                     [set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q) as degree]
                     factor = (-1/1) * x^(2-1) = -x
                     [update quotient = polyAddition(quotient, factor)]
                     quotient = x^2 + -x = x^2 - x
                     [update remainder = polyAddition(remainder, negate (polyMultiplication(q, factor)))]
                     remainder = (-x^2 + x - 1) + (-(x + 1) * (-x)) = (-x^2 + x - 1) + (x^2 + x) = 2x - 1

        Iteration 3: quotient = (x^2 - x) ; remainder = (2x - 1) ; q = (x + 1)
                     [set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q) as degree]
                     factor = (2-1) * x^(1-1) = 2
                     [update quotient = polyAddition(quotient, factor)]
                     quotient = x^2 - x + 2
                     [update remainder = polyAddition(remainder, negate (polyMultiplication(q, factor)))]
                     remainder = (2x - 1) + (-(x + 1) * 2) = (2x - 1) + (-2x - 2) = -3

        1st remainder degree < 1st q degree (0 < 1)
        quotient = x^2 - x + 2
    }


Problem 1.

(a) toString(), it needs to manually compute the reduced form so find the gcd of both number and divide it by the gcd.
    This added complexity to the codes.
    equals(), first convert both RatNum to reduced form if obj is an instance of RatNum and it is not NaN, then we can compare the two.
    This added complexity to the code.
    2 argument constructor, we no longer need to return a RatNum in reduced form, take out the part where converting to reduced form
    This decreased the amount of codes in the constructor which makes it more efficient, but now some other methods need to have some way to check for reduced form which is redundant
    checkRep(), we only need to check denom >= 0, we can safely remove the part where it is checking gcd == 1,
    This decreased the complexity of the code because every time checkRep() has lees codes to run.

    Overall, We have less code to run when constructing the object, but more code to run for converting to reduced form when comparing objects or doing toString
    One clear disadvantage of the new invariant is that we have to check whether the object is in its lowest form each time which is very redundant.

(b) With the change, the datatype will no longer be immutable, simply because we are modifying an object's field,
    rather than making a new one with our desired value. Also, we can easily break the rep invariant when we do not use checkRep()
    for mul and div. Creating a new object will call checkRep() every time it is constructed, but no checkRep() will be called if we modify fields

(c) Every method in RatNum is not a modifier, it is either an observer or creator. Once a RatNum() is constructed, it stays that way,
    So having only call checkRep() once is sufficient for that reason.


Problem 2.

(a) At the end of the constructor, and the beginning of every public method with RatTerm return type, the beginning and end of every non RatTerm return type method.
    We want to ensure rep invariant holds when the object is constructed, so it is reasonable to check before it exit the constructor
    When a public method is called, we need to check at the beginning if rep invariant is satisfied to avoid weird/unexpected output.
    When a public creator method that returns RatTerm such as add, sub. When the return object is created, it has a checkRep in the constructor.
    As for observers that don't call other methods, it will never modified anything and it is only returning the field. So only need a checkRep() on entry

(b) In the constructor, we can remove the if-branch that test coeff == ZERO.
    This makes the method less complex
    toString(), add an new if-branch to the top that checks for whether coeff is 0, append 0 if true.
    This makes things more complex because of the new if-branch, but the codes become more clear since the old toString does explicitly have a branch for 0 coeff
    equals() needs to check specifically for 0 coeff, with different expt. So we have to add an else-if branch into the code for both coeff to be 0
    This extra branch makes to code more complex because the old one just check if everything is the same or NaN.
    checkRep() no longer needs to have the second assertion.
    Shorten the amount of codes needs to execute.

    Overall the code is more efficient when running since we remove many codes that previously check for 0 expt with 0 coeff,
    Aside toString() & equals() becomes slightly more complex and less efficient due to the extra if-branch

(c) In the constructor, we can change the if test from (c.equals(RatNum.ZERO)) to (c.equals(RatNum.ZERO) || c.equals(RatNum.NaN),
    And checkRep() needs to have a branch that checks if NaN then expt must be 0
    So we don't a clear advantage or disadvantage on one over the other since the code does not change much other than a few more lines which decrease the efficiency slightly

    I prefer having {coeff.equals(RatNum.ZERO) â‡’ expt = 0}. Since all of the implementation of RatTerm specifically return NaN
    when the coeff is NaN, it is more better to have that as the rep invariant, which affect output and calculations.


Problem 3.
(a) At the end of each constructor, beginning for RatPoly return type, beginning & end for other return types.
    For methods that return RatPoly, the return objects are construct right before it gets return, so the checkRep() in the constructor will be called last
    For other methods, we need to ensure the rep invariant holds on entry and on exit, since we do not construct any new RatPoly.
    Even for observers, the implementations are slightly long and complex compared to RatTerm's observers, having a checkRep at the end here is to ensure.

(b) We need more code to check both list that they don't violate the rep invariant, such as having 0 coeff, we cannot just call methods from RatTerm.
    And when we change the list element, we have to handle both list to get the result we want which can be really complex.
    The advantage of this implementation is doesn't have to call RatTerm which call RatNum, which make it more efficient in that way.
    I think using RatTerm is better than having 2 lists, just simply because it is easier to implement than the other, there's only one field we need to handle which is the RatTerm


Problem 5.
1) x^2+2*x+3
2) x^3+3*x^2+2*x+7
3) x^4+x^3+x^2+8
4) x^2+6*x+9