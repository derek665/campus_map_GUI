CSE 331 Homework 4.  Answers to written questions.
Edit this file to supply your answers.

Name:  Derek Chan

Problem 0.

(a) r = p * q :
        set r = 0
        {inv1 : r = p_0 * q + p_1 * q + .... + p_(i - 1) * q, where p_i is the i-th term of p}
        foreach term, t_p in p {
            set j = 0
            {inv2 : j = t_p * q_0 + t_p * q_1 + ..... + t_p * q_(i - 1), where q_i is the i-term of q}
            foreach term, t_q in q {
                update j = j + t_p * t_q (call the polynomial addition here with j and (t_p * t_q))
                (t_p * t_q = coefficient of t_p * coefficient of t_q with degree of t_p + degree of t_q)
            }
            r = r + j (call the polynomial addition here with r and j)
        }

(b) r = p / q
        set quotient = 0
        set remainder = deep copy of p
        {inv : quotient = quotient + (1st remainder coefficient divided by 1st q coefficient, with degree of 1st remainder degree - 1st q degree) ;
               remainder = remainder - ((1st remainder coefficient divided by 1st q coefficient) * q) }
        while (remainder > 0 && (1st remainder degree >= 1st q degree)) {
             set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q (integer sub)) as degree
             update quotient = polyAddition(quotient, factor)
             update remainder = polyAddition(remainder,  polyMultiplication(polyMultiplication(q, factor)), -1))
        }


(c) (x^3 + x - 1) / (x + 1) = x^2 - x + 2
    p = (x^3 + x - 1)       q = (x + 1)
    quotient = 0        remainder = copy of p : (x^3 + x - 1)
    while (remainder > 0 && (1st remainder degree >= 1st q degree)) {
        Iteration 1: quotient = 0 ; remainder = (x^3 + x - 1) ; q = (x + 1)
                     [set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q) as degree]
                     factor = (1/1) * x^(3-1) = x^2
                     [update quotient = polyAddition(quotient, factor)]
                     quotient = 0 + x^2 = x^2
                     [update remainder = polyAddition(remainder, negate (polyMultiplication(q, factor)))]
                     remainder = (x^3 + x - 1) + (-(x + 1) * x^2) = (x^3 + x - 1) + (-x^3 - x^2) = -x^2 + x - 1

        Iteration 2: quotient = (x^2) ; remainder = (-x^2 + x - 1) ; q = (x + 1)
                     [set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q) as degree]
                     factor = (-1/1) * x^(2-1) = -x
                     [update quotient = polyAddition(quotient, factor)]
                     quotient = x^2 + -x = x^2 - x
                     [update remainder = polyAddition(remainder, negate (polyMultiplication(q, factor)))]
                     remainder = (-x^2 + x - 1) + (-(x + 1) * (-x)) = (-x^2 + x - 1) + (x^2 + x) = 2x - 1

        Iteration 3: quotient = (x^2 - x) ; remainder = (2x - 1) ; q = (x + 1)
                     [set factor = a term with (1st coefficient remainder / 1st coefficient q (this is integer division)) and (1st degree remainder - 1st degree q) as degree]
                     factor = (2-1) * x^(1-1) = 2
                     [update quotient = polyAddition(quotient, factor)]
                     quotient = x^2 - x + 2
                     [update remainder = polyAddition(remainder, negate (polyMultiplication(q, factor)))]
                     remainder = (2x - 1) + (-(x + 1) * 2) = (2x - 1) + (-2x - 2) = -3

        1st remainder degree < 1st q degree (0 < 1)
        quotient = x^2 - x + 2
    }


Problem 1.

(a) toString(), it needs to manually compute the reduced form so find the gcd of both number and divide it by the gcd
    equals(), first convert both RatNum to reduced form if obj is an instance of RatNum and it is not NaN, then we can compare the two
    2 argument constructor, we no longer need to return a RatNum in reduced form, take out the part where converting to reduced form to make code simpler
    checkRep(), we only need to check denom >= 0, we can safely remove the part where it is checking gcd == 1.

    We have less code to run when constructing the object, but more code to run for converting to reduced form when comparing objects or doing toString

(b) With the change, the datatype will no longer be immutable, simply because we are modifying an object's field,
    rather than making a new one with our desired value. Also, we can easily break the rep invariant when we do not use checkRep()
    for mul and div. Creating a new object will call checkRep() every time it is constructed, but no checkRep() will be called if we modify fields

(c) Every method in RatNum is not a modifier, it is either an observer or creator. Once a RatNum() is constructed, it stays that way,
    So having only call checkRep() once is sufficient for that reason.


Problem 2.

(a) At the end of the constructor, because fields are not mutable so only need to check once.
    and creator methods are returning a new RatTerm so it will have a checkRep() in the constructor

(b) In the constructor, we can remove the if-branch that test coeff == ZERO
    toString(), add an new if-branch to the top that checks for whether coeff is 0, append 0 if true
    checkRep() no longer needs to have the second assertion.

    Overall the code is more efficient when running since we remove many codes that previously check for 0 expt with 0 coeff,
    Aside toString() becomes slightly more complex and less efficient due to the extra if-branch

(c) In the constructor, we can change the if test from (c.equals(RatNum.ZERO)) to (c.equals(RatNum.ZERO) || c.equals(RatNum.NaN),
    the code does not change much other than the if-branch in the constructor which is an inexpensive check.
    So we don't a clear advantage or disadvantage on one over the other.

    I prefer having {coeff.equals(RatNum.ZERO) â‡’ expt = 0}. Since all of the implementation of RatTerm specifically return NaN
    when the coeff is NaN, it is more practical to have that as the rep invariant, where it actually affects the output.


Problem 3.
(a) At the end of each constructor, since the class is immutable, there is no need to have checkRep() elsewhere.
    For method such as add, sub, mul, and div. The method every time returns a new RatPoly as a result,
    so it will run checkRep() when the new RatPoly is created right before it gets returned.

(b) We need more code to check both list that they don't violate the rep invariant, such as having 0 coeff. And when we change the list element,
    we have to handle both list to get the result we want which can be really complex. The advantage of this implementation is doesn't have to
    call RatTerm which call RatNum, which make it more efficient in that way. I think using RatTerm is better than having 2 lists, just simply
    because it is easier to implement than the other, there's only one field we need to handle which is the RatTerm


Problem 5.
1) x^2+2x+3
2) x^3+3x^2+2x+7
3) x^4+x^3+x^2+8
4) x^2+6x+9